class Solution {
public:
    // MEMOISATION(TOP DOWN APPROACH)
    // int path(int m, int n, int row, int col, vector<vector<int>> &dp,vector<vector<int>> &obstacleGrid)
    // {
    //     if(row>=m || col>=n)
    //      return 0;
    //     if(row==m-1 && col==n-1)
    //      return 1;
    //     if(dp[row][col]!=-1)
    //       return dp[row][col]; 
    //     if(obstacleGrid[row][col]==1)
    //      return 0;
    //     int right=path(m,n,row, col+1,dp,obstacleGrid);
    //     int down=path(m,n, row+1, col,dp,obstacleGrid);
    //     return dp[row][col]=right+down;  
    // }
    
    // TABULATION(BOTTOM UP APPROACH)
    // int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) 
    // {
    //   int m=obstacleGrid.size();
    //   int n=obstacleGrid[0].size();
    //   if(obstacleGrid[m-1][n-1]==1)
    //    return 0;
    //  vector<vector<int>> dp(m,vector<int>(n,0));
    //    if(obstacleGrid[0][0]!=1)
    //     dp[0][0]=1;
    //    for(int i=0;i<m;i++)
    //    {
    //        for(int j=0;j<n;j++)
    //        {
    //           if((i==0 && j==0)|| obstacleGrid[i][j]==1)
    //            continue;
    //           int right=0,down=0;
    //           if(j>0)
    //            right=dp[i][j-1];
    //           if(i>0) 
    //            down=dp[i-1][j];
    //           dp[i][j]=right+down; 
    //        }
    //    }
    //    return dp[m-1][n-1];  
    // }
    
    // SPACE OPTIMISATION
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) 
    {
      int m=obstacleGrid.size();
      int n=obstacleGrid[0].size();
      if(obstacleGrid[m-1][n-1]==1)
       return 0;
      vector<int> prev(n,0);
      vector<int> curr(n,0);
       if(obstacleGrid[0][0]!=1)
       {
           prev[0]=1;
           curr[0]=1;
       }
       for(int i=0;i<m;i++)
       {
           for(int j=0;j<n;j++)
           {
              if(i==0 && j==0)
               continue;
              if(obstacleGrid[i][j]==1){
                  curr[j]=0;
                  prev[j]=0;
              }
              else{
              int right=0,down=0;
              if(j>0)
               right=curr[j-1];
              if(i>0) 
               down=prev[j];
              curr[j]=right+down; 
              }
           }
           prev=curr;
       }
       return prev[n-1];  
    }
};
