class Solution {
public:
    // MEMOISATION(TOP DOWN APPROACH)
    // int minpath(vector<vector<int>> &grid, int row, int col, vector<vector<int>> &dp)
    // {
    //     if(row==0 && col==0)
    //      return grid[row][col];
    //     if(row<0 || col<0)
    //      return 1e9;
    //     if(dp[row][col]!=-1)
    //      return dp[row][col];  
    //     int left=grid[row][col]+minpath(grid, row, col-1,dp);
    //     int up=grid[row][col]+minpath(grid,row-1,col,dp);
    //     return dp[row][col]=min(left,up);
    // }
    
    //TABULATION(BOTTOM UP APPROACH)
    // int minPathSum(vector<vector<int>> &grid){
    //     int n=grid.size();
    //     int m=grid[0].size();
    //     vector<vector<int>> dp(n,vector<int>(m,0));
    //     for(int row=0;row<n;row++){
    //         for(int col=0;col<m;col++){
    //              if(row==0 && col==0){
    //                  dp[row][col]=grid[row][col];
    //                  continue;
    //              }
    //              int left=1e9;
    //              if((col-1)>=0)
    //               left=grid[row][col]+dp[row][col-1];
    //              int up=1e9;
    //              if((row-1)>=0)
    //               up=grid[row][col]+dp[row-1][col];
    //              dp[row][col]=min(left,up);
    //         }
    //     }
    //     return dp[n-1][m-1];
    // }

    // SPACE OPTIMISATION
    int minPathSum(vector<vector<int>>& grid) 
    {
        int n=grid.size();
        int m=grid[0].size();
        vector<int> curr(m,0), prev(m,0);
        for(int row=0;row<n;row++)
        {
            for(int col=0;col<m;col++)
            {
                if(row==0 && col==0)
                 curr[col]=grid[row][col];
                else
                {
                  int left=INT_MAX;
                  if(col>=1)
                   left=grid[row][col]+curr[col-1];
                  int up=INT_MAX;
                  if(row>=1) 
                   up=grid[row][col]+prev[col];
                  curr[col]=min(left,up);  
                } 
            }
            prev=curr;
        }
        return prev[m-1];
    }
};
